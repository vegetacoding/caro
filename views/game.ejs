<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>C·ªù Caro</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
    <style>
      body {
        font-family: "Arial", sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        margin: 0;
        background: linear-gradient(135deg, #1e3c72, #2a5298);
        color: white;
        padding: 20px;
      }

      .container {
        text-align: center;
      }

      h1 {
        font-size: 2.5em;
        margin-bottom: 30px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .game-board {
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        gap: 2px;
        margin: 20px auto;
        background: rgba(255, 255, 255, 0.1);
        padding: 10px;
        border-radius: 15px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      }

      .cell {
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 4px;
        font-size: 1.2em;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        color: #2a5298; /* Default color */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .cell.x-move {
        color: #2a5298; /* M√†u xanh cho ng∆∞·ªùi ch∆°i X */
        text-shadow: 0 0 5px rgba(42, 82, 152, 0.3);
      }

      .cell.o-move {
        color: #e74c3c; /* M√†u ƒë·ªè cho m√°y O */
        text-shadow: 0 0 5px rgba(231, 76, 60, 0.3);
      }

      .cell:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.05);
      }

      .status {
        font-size: 1.5em;
        margin: 20px 0;
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
      }

      .restart-btn {
        padding: 12px 30px;
        font-size: 1.2em;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-top: 20px;
      }

      .restart-btn:hover {
        background: #45a049;
        transform: scale(1.05);
      }

      @media (max-width: 500px) {
        .cell {
          width: 30px;
          height: 30px;
          font-size: 0.9em;
        }
      }

      /* Modal styles */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        animation: fadeIn 0.3s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #43cea2, #185a9d);
        padding: 30px;
        border-radius: 20px;
        text-align: center;
        box-shadow: 0 5px 30px rgba(0, 0, 0, 0.3);
        animation: slideIn 0.5s ease-out;
      }

      @keyframes slideIn {
        from {
          transform: translate(-50%, -60%);
          opacity: 0;
        }
        to {
          transform: translate(-50%, -50%);
          opacity: 1;
        }
      }

      .modal h2 {
        font-size: 2.5em;
        margin-bottom: 20px;
        color: #fff;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      }

      .modal p {
        font-size: 1.2em;
        margin-bottom: 30px;
        color: #fff;
      }

      .modal-btn {
        padding: 12px 30px;
        font-size: 1.2em;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 10px;
      }

      .modal-btn:hover {
        transform: scale(1.05);
        background: #45a049;
      }

      .trophy {
        font-size: 4em;
        margin-bottom: 20px;
        text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>C·ªù Caro</h1>
      <div class="status" id="status">L∆∞·ª£t c·ªßa b·∫°n (X)</div>
      <div class="game-board" id="board">
        <!-- Board will be generated by JavaScript -->
      </div>
      <button class="restart-btn" onclick="restartGame()">Ch∆°i l·∫°i</button>
    </div>

    <!-- Victory Modal -->
    <div id="victoryModal" class="modal">
      <div class="modal-content">
        <div class="trophy">üèÜ</div>
        <h2>Ch√∫c m·ª´ng!</h2>
        <p id="victoryMessage">B·∫°n ƒë√£ chi·∫øn th·∫Øng!</p>
        <button class="modal-btn" onclick="restartGame()">Ch∆°i l·∫°i</button>
      </div>
    </div>

    <script>
      const BOARD_SIZE = 10;
      const WINNING_LENGTH = 5; // S·ªë qu√¢n c·ªù li√™n ti·∫øp ƒë·ªÉ th·∫Øng
      let board = Array(BOARD_SIZE * BOARD_SIZE).fill("");
      let currentPlayer = "X";
      let gameActive = true;

      // T·∫°o b√†n c·ªù
      function createBoard() {
        const gameBoard = document.getElementById("board");
        gameBoard.innerHTML = "";
        for (let i = 0; i < BOARD_SIZE * BOARD_SIZE; i++) {
          const cell = document.createElement("button");
          cell.className = "cell";
          cell.setAttribute("data-index", i);
          cell.addEventListener("click", () => handleCellClick(cell));
          gameBoard.appendChild(cell);
        }
      }

      function handleCellClick(cell) {
        const index = parseInt(cell.getAttribute("data-index"));

        if (board[index] !== "" || !gameActive) return;

        makeMove(index);

        if (gameActive) {
          setTimeout(makeAIMove, 500);
        }
      }

      function makeMove(index) {
        board[index] = currentPlayer;
        const cell = document.querySelector(`[data-index="${index}"]`);
        cell.textContent = currentPlayer;
        cell.className = `cell ${currentPlayer.toLowerCase()}-move`; // Th√™m class ƒë·ªÉ ƒë·ªïi m√†u

        if (checkWin(index)) {
          document.getElementById(
            "status"
          ).textContent = `${currentPlayer} th·∫Øng!`;
          gameActive = false;
          showVictoryModal(currentPlayer);
          return;
        }

        if (checkDraw()) {
          document.getElementById("status").textContent = "H√≤a!";
          gameActive = false;
          return;
        }

        currentPlayer = currentPlayer === "X" ? "O" : "X";
        document.getElementById("status").textContent = `L∆∞·ª£t c·ªßa ${
          currentPlayer === "X" ? "b·∫°n (X)" : "m√°y (O)"
        }`;
      }

      function makeAIMove() {
        let bestMove = findBestMove();
        if (bestMove !== -1) {
          makeMove(bestMove);
        }
      }

      function findBestMove() {
        // T√¨m n∆∞·ªõc ƒëi chi·∫øn th·∫Øng ngay l·∫≠p t·ª©c
        for (let i = 0; i < board.length; i++) {
          if (board[i] === "") {
            board[i] = "O";
            if (checkWin(i)) {
              board[i] = "";
              return i;
            }
            board[i] = "";
          }
        }

        // Ch·∫∑n n∆∞·ªõc ƒëi chi·∫øn th·∫Øng c·ªßa ng∆∞·ªùi ch∆°i
        for (let i = 0; i < board.length; i++) {
          if (board[i] === "") {
            board[i] = "X";
            if (checkWin(i)) {
              board[i] = "";
              return i;
            }
            board[i] = "";
          }
        }

        // ƒê√°nh gi√° c√°c n∆∞·ªõc ƒëi ti·ªÅm nƒÉng
        let bestScore = -Infinity;
        let bestMove = -1;

        for (let i = 0; i < board.length; i++) {
          if (board[i] === "") {
            const score = evaluateMove(i, "O");
            if (score > bestScore) {
              bestScore = score;
              bestMove = i;
            }
          }
        }

        if (bestMove !== -1) return bestMove;

        // N·∫øu kh√¥ng t√¨m ƒë∆∞·ª£c n∆∞·ªõc ƒëi t·ªët, ch·ªçn ng·∫´u nhi√™n
        let availableSpots = board.reduce((acc, cell, index) => {
          if (cell === "") acc.push(index);
          return acc;
        }, []);

        if (availableSpots.length > 0) {
          return availableSpots[
            Math.floor(Math.random() * availableSpots.length)
          ];
        }
        return -1;
      }

      function evaluateMove(index, player) {
        const row = Math.floor(index / BOARD_SIZE);
        const col = index % BOARD_SIZE;
        let score = 0;

        // Ki·ªÉm tra v√† t√≠nh ƒëi·ªÉm theo c√°c h∆∞·ªõng
        const directions = [
          [0, 1], // ngang
          [1, 0], // d·ªçc
          [1, 1], // ch√©o ch√≠nh
          [1, -1], // ch√©o ph·ª•
        ];

        for (const [dx, dy] of directions) {
          score += evaluateDirection(row, col, dx, dy, player);
          score += evaluateDirection(row, col, -dx, -dy, player);
        }

        // Th√™m ƒëi·ªÉm cho v·ªã tr√≠ chi·∫øn l∆∞·ª£c
        score += evaluatePosition(row, col);

        return score;
      }

      function evaluateDirection(row, col, dx, dy, player) {
        let score = 0;
        let ownCount = 0;
        let emptyCount = 0;
        let blocked = false;

        // Ki·ªÉm tra 4 √¥ li√™n ti·∫øp theo h∆∞·ªõng
        for (let i = 1; i <= 4; i++) {
          const newRow = row + dx * i;
          const newCol = col + dy * i;

          if (
            newRow < 0 ||
            newRow >= BOARD_SIZE ||
            newCol < 0 ||
            newCol >= BOARD_SIZE
          ) {
            blocked = true;
            break;
          }

          const cell = board[newRow * BOARD_SIZE + newCol];
          if (cell === player) {
            ownCount++;
          } else if (cell === "") {
            emptyCount++;
          } else {
            blocked = true;
            break;
          }
        }

        // T√≠nh ƒëi·ªÉm d·ª±a tr√™n s·ªë qu√¢n c·ªù li√™n ti·∫øp v√† kho·∫£ng tr·ªëng
        if (!blocked) {
          if (ownCount >= 3) score += 100; // C∆° h·ªôi chi·∫øn th·∫Øng cao
          else if (ownCount === 2) score += 10; // Ti·ªÅm nƒÉng t·∫°o chu·ªói
          else if (ownCount === 1) score += 1; // Kh·ªüi ƒë·∫ßu chu·ªói

          score *= emptyCount + 1; // Nh√¢n v·ªõi s·ªë √¥ tr·ªëng ƒë·ªÉ ∆∞u ti√™n nh·ªØng n∆∞·ªõc c√≥ nhi·ªÅu kh·∫£ nƒÉng m·ªü r·ªông
        }

        return score;
      }

      function evaluatePosition(row, col) {
        let score = 0;

        // ∆Øu ti√™n c√°c v·ªã tr√≠ ·ªü trung t√¢m
        const centerRow = BOARD_SIZE / 2;
        const centerCol = BOARD_SIZE / 2;
        const distanceToCenter = Math.sqrt(
          Math.pow(row - centerRow, 2) + Math.pow(col - centerCol, 2)
        );
        score += Math.max(0, 5 - distanceToCenter);

        // ∆Øu ti√™n c√°c v·ªã tr√≠ c√≥ nhi·ªÅu n∆∞·ªõc ƒëi ti·∫øp theo
        let adjacentMoves = 0;
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            if (i === 0 && j === 0) continue;

            const newRow = row + i;
            const newCol = col + j;

            if (
              newRow >= 0 &&
              newRow < BOARD_SIZE &&
              newCol >= 0 &&
              newCol < BOARD_SIZE
            ) {
              if (board[newRow * BOARD_SIZE + newCol] !== "") {
                adjacentMoves++;
              }
            }
          }
        }
        score += adjacentMoves * 2;

        return score;
      }

      function checkWin(lastMove) {
        const row = Math.floor(lastMove / BOARD_SIZE);
        const col = lastMove % BOARD_SIZE;
        const player = board[lastMove];

        // Ki·ªÉm tra h√†ng ngang
        for (
          let c = Math.max(0, col - 4);
          c <= Math.min(BOARD_SIZE - WINNING_LENGTH, col);
          c++
        ) {
          let count = 0;
          for (let i = 0; i < WINNING_LENGTH; i++) {
            if (board[row * BOARD_SIZE + (c + i)] === player) {
              count++;
            } else {
              break;
            }
          }
          if (count === WINNING_LENGTH) return true;
        }

        // Ki·ªÉm tra h√†ng d·ªçc
        for (
          let r = Math.max(0, row - 4);
          r <= Math.min(BOARD_SIZE - WINNING_LENGTH, row);
          r++
        ) {
          let count = 0;
          for (let i = 0; i < WINNING_LENGTH; i++) {
            if (board[(r + i) * BOARD_SIZE + col] === player) {
              count++;
            } else {
              break;
            }
          }
          if (count === WINNING_LENGTH) return true;
        }

        // Ki·ªÉm tra ƒë∆∞·ªùng ch√©o ch√≠nh
        for (let i = -4; i <= 0; i++) {
          let count = 0;
          for (let j = 0; j < WINNING_LENGTH; j++) {
            const r = row + i + j;
            const c = col + i + j;
            if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
              if (board[r * BOARD_SIZE + c] === player) {
                count++;
              } else {
                break;
              }
            }
          }
          if (count === WINNING_LENGTH) return true;
        }

        // Ki·ªÉm tra ƒë∆∞·ªùng ch√©o ph·ª•
        for (let i = -4; i <= 0; i++) {
          let count = 0;
          for (let j = 0; j < WINNING_LENGTH; j++) {
            const r = row + i + j;
            const c = col - i - j;
            if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE) {
              if (board[r * BOARD_SIZE + c] === player) {
                count++;
              } else {
                break;
              }
            }
          }
          if (count === WINNING_LENGTH) return true;
        }

        return false;
      }

      function checkDraw() {
        return board.every((cell) => cell !== "");
      }

      function showVictoryModal(winner) {
        const modal = document.getElementById("victoryModal");
        const message = document.getElementById("victoryMessage");
        message.textContent =
          winner === "X" ? "B·∫°n ƒë√£ chi·∫øn th·∫Øng!" : "M√°y ƒë√£ chi·∫øn th·∫Øng!";
        modal.style.display = "block";

        // Hi·ªáu ·ª©ng ph√°o hoa
        const duration = 3000;
        const animationEnd = Date.now() + duration;
        const defaults = {
          startVelocity: 30,
          spread: 360,
          ticks: 60,
          zIndex: 1001,
        };

        function randomInRange(min, max) {
          return Math.random() * (max - min) + min;
        }

        const interval = setInterval(function () {
          const timeLeft = animationEnd - Date.now();

          if (timeLeft <= 0) {
            return clearInterval(interval);
          }

          const particleCount = 50 * (timeLeft / duration);

          confetti({
            ...defaults,
            particleCount,
            origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 },
          });
          confetti({
            ...defaults,
            particleCount,
            origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 },
          });
        }, 250);
      }

      function restartGame() {
        board = Array(BOARD_SIZE * BOARD_SIZE).fill("");
        currentPlayer = "X";
        gameActive = true;
        document.querySelectorAll(".cell").forEach((cell) => {
          cell.textContent = "";
          cell.className = "cell"; // Reset class v·ªÅ m·∫∑c ƒë·ªãnh
        });
        document.getElementById("status").textContent = "L∆∞·ª£t c·ªßa b·∫°n (X)";
        document.getElementById("victoryModal").style.display = "none";
      }

      // Kh·ªüi t·∫°o game
      createBoard();
    </script>
  </body>
</html>
